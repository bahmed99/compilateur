Règles inutiles dans l'analyseur à cause de conflits

   34 then: THEN

   35 else: ELSE


État 58 conflits: 6 réduction/réduction
État 86 conflits: 6 réduction/réduction


Grammaire

    0 $accept: prog $end

    1 prog: inst PV
    2     | prog inst PV

    3 inst: let_def
    4     | exp

    5 let_def: def_id
    6        | def_fun

    7 def_id: LET ID EQ exp

    8 def_fun: LET fun_head EQ exp

    9 fun_head: ID LPAR id_list RPAR

   10 id_list: ID
   11        | id_list VIR ID

   12 exp: arith_exp
   13    | let_exp

   14 arith_exp: MOINS arith_exp
   15          | arith_exp MOINS arith_exp
   16          | arith_exp PLUS arith_exp
   17          | arith_exp DIV arith_exp
   18          | arith_exp MULT arith_exp
   19          | arith_exp CONCAT arith_exp
   20          | atom_exp

   21 atom_exp: NUM
   22         | FLOAT
   23         | STRING
   24         | ID
   25         | control_exp
   26         | funcall_exp
   27         | LPAR exp RPAR

   28 control_exp: if_exp

   29 if_exp: if cond then atom_exp else atom_exp

   30 if: IF

   31 cond: LPAR bool RPAR

   32 then: THEN

   33 else: ELSE

   34 then: THEN

   35 else: ELSE

   36 let_exp: let_def IN atom_exp
   37        | let_def IN let_exp

   38 funcall_exp: ID LPAR arg_list RPAR

   39 arg_list: arith_exp
   40         | arg_list VIR arith_exp

   41 bool: BOOL
   42     | bool OR bool
   43     | bool AND bool
   44     | NOT bool
   45     | exp comp exp
   46     | LPAR bool RPAR

   47 comp: ISLT
   48     | ISGT
   49     | ISLEQ
   50     | ISGEQ
   51     | ISEQ


Terminaux, suivis des règles où ils apparaissent

    $end (0) 0
    error (256)
    NUM <val> (258) 21
    ID <val> (259) 7 9 10 11 24 38
    FLOAT <val> (260) 22
    STRING (261) 23
    PV (262) 1 2
    LPAR (263) 9 27 31 38 46
    RPAR (264) 9 27 31 38 46
    LET (265) 7 8
    IN (266) 36 37
    VIR (267) 11 40
    IF (268) 30
    THEN (269) 32 34
    ELSE (270) 33 35
    ISLT (271) 47
    ISGT (272) 48
    ISLEQ (273) 49
    ISGEQ (274) 50
    ISEQ (275) 51
    AND (276) 43
    OR (277) 42
    NOT (278) 44
    BOOL (279) 41
    PLUS (280) 16
    MOINS (281) 14 15
    MULT (282) 18
    DIV (283) 17
    EQ (284) 7 8
    CONCAT (285) 19
    UNA (286)


Non-terminaux, suivis des règles où ils apparaissent

    $accept (32)
        à gauche: 0
    prog (33)
        à gauche: 1 2
        à droite: 0 2
    inst (34)
        à gauche: 3 4
        à droite: 1 2
    let_def (35)
        à gauche: 5 6
        à droite: 3 36 37
    def_id (36)
        à gauche: 7
        à droite: 5
    def_fun (37)
        à gauche: 8
        à droite: 6
    fun_head (38)
        à gauche: 9
        à droite: 8
    id_list (39)
        à gauche: 10 11
        à droite: 9 11
    exp <val> (40)
        à gauche: 12 13
        à droite: 4 7 8 27 45
    arith_exp (41)
        à gauche: 14 15 16 17 18 19 20
        à droite: 12 14 15 16 17 18 19 39 40
    atom_exp (42)
        à gauche: 21 22 23 24 25 26 27
        à droite: 20 29 36
    control_exp (43)
        à gauche: 28
        à droite: 25
    if_exp (44)
        à gauche: 29
        à droite: 28
    if (45)
        à gauche: 30
        à droite: 29
    cond (46)
        à gauche: 31
        à droite: 29
    then (47)
        à gauche: 32 34
        à droite: 29
    else (48)
        à gauche: 33 35
        à droite: 29
    let_exp (49)
        à gauche: 36 37
        à droite: 13 37
    funcall_exp (50)
        à gauche: 38
        à droite: 26
    arg_list (51)
        à gauche: 39 40
        à droite: 38 40
    bool (52)
        à gauche: 41 42 43 44 45 46
        à droite: 31 42 43 44 46
    comp (53)
        à gauche: 47 48 49 50 51
        à droite: 45


État 0

    0 $accept: • prog $end

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    prog         aller à l'état 9
    inst         aller à l'état 10
    let_def      aller à l'état 11
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 14
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21


État 1

   21 atom_exp: NUM •

    $défaut  réduction par utilisation de la règle 21 (atom_exp)


État 2

   24 atom_exp: ID •
   38 funcall_exp: ID • LPAR arg_list RPAR

    LPAR  décalage et aller à l'état 22

    $défaut  réduction par utilisation de la règle 24 (atom_exp)


État 3

   22 atom_exp: FLOAT •

    $défaut  réduction par utilisation de la règle 22 (atom_exp)


État 4

   23 atom_exp: STRING •

    $défaut  réduction par utilisation de la règle 23 (atom_exp)


État 5

   27 atom_exp: LPAR • exp RPAR

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 24
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21


État 6

    7 def_id: LET • ID EQ exp
    8 def_fun: LET • fun_head EQ exp

    ID  décalage et aller à l'état 25

    fun_head  aller à l'état 26


État 7

   30 if: IF •

    $défaut  réduction par utilisation de la règle 30 (if)


État 8

   14 arith_exp: MOINS • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 27
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 9

    0 $accept: prog • $end
    2 prog: prog • inst PV

    $end    décalage et aller à l'état 28
    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    inst         aller à l'état 29
    let_def      aller à l'état 11
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 14
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21


État 10

    1 prog: inst • PV

    PV  décalage et aller à l'état 30


État 11

    3 inst: let_def •
   36 let_exp: let_def • IN atom_exp
   37        | let_def • IN let_exp

    IN  décalage et aller à l'état 31

    $défaut  réduction par utilisation de la règle 3 (inst)


État 12

    5 let_def: def_id •

    $défaut  réduction par utilisation de la règle 5 (let_def)


État 13

    6 let_def: def_fun •

    $défaut  réduction par utilisation de la règle 6 (let_def)


État 14

    4 inst: exp •

    $défaut  réduction par utilisation de la règle 4 (inst)


État 15

   12 exp: arith_exp •
   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    PLUS    décalage et aller à l'état 32
    MOINS   décalage et aller à l'état 33
    MULT    décalage et aller à l'état 34
    DIV     décalage et aller à l'état 35
    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 12 (exp)


État 16

   20 arith_exp: atom_exp •

    $défaut  réduction par utilisation de la règle 20 (arith_exp)


État 17

   25 atom_exp: control_exp •

    $défaut  réduction par utilisation de la règle 25 (atom_exp)


État 18

   28 control_exp: if_exp •

    $défaut  réduction par utilisation de la règle 28 (control_exp)


État 19

   29 if_exp: if • cond then atom_exp else atom_exp

    LPAR  décalage et aller à l'état 37

    cond  aller à l'état 38


État 20

   13 exp: let_exp •

    $défaut  réduction par utilisation de la règle 13 (exp)


État 21

   26 atom_exp: funcall_exp •

    $défaut  réduction par utilisation de la règle 26 (atom_exp)


État 22

   38 funcall_exp: ID LPAR • arg_list RPAR

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 39
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21
    arg_list     aller à l'état 40


État 23

   36 let_exp: let_def • IN atom_exp
   37        | let_def • IN let_exp

    IN  décalage et aller à l'état 31


État 24

   27 atom_exp: LPAR exp • RPAR

    RPAR  décalage et aller à l'état 41


État 25

    7 def_id: LET ID • EQ exp
    9 fun_head: ID • LPAR id_list RPAR

    LPAR  décalage et aller à l'état 42
    EQ    décalage et aller à l'état 43


État 26

    8 def_fun: LET fun_head • EQ exp

    EQ  décalage et aller à l'état 44


État 27

   14 arith_exp: MOINS arith_exp •
   15          | arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    $défaut  réduction par utilisation de la règle 14 (arith_exp)


État 28

    0 $accept: prog $end •

    $défaut  accepter


État 29

    2 prog: prog inst • PV

    PV  décalage et aller à l'état 45


État 30

    1 prog: inst PV •

    $défaut  réduction par utilisation de la règle 1 (prog)


État 31

   36 let_exp: let_def IN • atom_exp
   37        | let_def IN • let_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    atom_exp     aller à l'état 46
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 47
    funcall_exp  aller à l'état 21


État 32

   16 arith_exp: arith_exp PLUS • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 48
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 33

   15 arith_exp: arith_exp MOINS • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 49
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 34

   18 arith_exp: arith_exp MULT • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 50
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 35

   17 arith_exp: arith_exp DIV • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 51
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 36

   19 arith_exp: arith_exp CONCAT • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 52
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 37

   31 cond: LPAR • bool RPAR

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 53
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    NOT     décalage et aller à l'état 54
    BOOL    décalage et aller à l'état 55
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 56
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21
    bool         aller à l'état 57


État 38

   29 if_exp: if cond • then atom_exp else atom_exp

    THEN  décalage et aller à l'état 58

    then  aller à l'état 59


État 39

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp
   39 arg_list: arith_exp •

    PLUS    décalage et aller à l'état 32
    MOINS   décalage et aller à l'état 33
    MULT    décalage et aller à l'état 34
    DIV     décalage et aller à l'état 35
    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 39 (arg_list)


État 40

   38 funcall_exp: ID LPAR arg_list • RPAR
   40 arg_list: arg_list • VIR arith_exp

    RPAR  décalage et aller à l'état 60
    VIR   décalage et aller à l'état 61


État 41

   27 atom_exp: LPAR exp RPAR •

    $défaut  réduction par utilisation de la règle 27 (atom_exp)


État 42

    9 fun_head: ID LPAR • id_list RPAR

    ID  décalage et aller à l'état 62

    id_list  aller à l'état 63


État 43

    7 def_id: LET ID EQ • exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 64
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21


État 44

    8 def_fun: LET fun_head EQ • exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 65
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21


État 45

    2 prog: prog inst PV •

    $défaut  réduction par utilisation de la règle 2 (prog)


État 46

   36 let_exp: let_def IN atom_exp •

    $défaut  réduction par utilisation de la règle 36 (let_exp)


État 47

   37 let_exp: let_def IN let_exp •

    $défaut  réduction par utilisation de la règle 37 (let_exp)


État 48

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   16          | arith_exp PLUS arith_exp •
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    MULT    décalage et aller à l'état 34
    DIV     décalage et aller à l'état 35
    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 16 (arith_exp)


État 49

   15 arith_exp: arith_exp • MOINS arith_exp
   15          | arith_exp MOINS arith_exp •
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    MULT    décalage et aller à l'état 34
    DIV     décalage et aller à l'état 35
    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 15 (arith_exp)


État 50

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   18          | arith_exp MULT arith_exp •
   19          | arith_exp • CONCAT arith_exp

    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 18 (arith_exp)


État 51

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   17          | arith_exp DIV arith_exp •
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp

    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 17 (arith_exp)


État 52

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp
   19          | arith_exp CONCAT arith_exp •

    $défaut  réduction par utilisation de la règle 19 (arith_exp)


État 53

   27 atom_exp: LPAR • exp RPAR
   46 bool: LPAR • bool RPAR

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 53
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    NOT     décalage et aller à l'état 54
    BOOL    décalage et aller à l'état 55
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 66
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21
    bool         aller à l'état 67


État 54

   44 bool: NOT • bool

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 53
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    NOT     décalage et aller à l'état 54
    BOOL    décalage et aller à l'état 55
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 56
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21
    bool         aller à l'état 68


État 55

   41 bool: BOOL •

    $défaut  réduction par utilisation de la règle 41 (bool)


État 56

   45 bool: exp • comp exp

    ISLT   décalage et aller à l'état 69
    ISGT   décalage et aller à l'état 70
    ISLEQ  décalage et aller à l'état 71
    ISGEQ  décalage et aller à l'état 72
    ISEQ   décalage et aller à l'état 73

    comp  aller à l'état 74


État 57

   31 cond: LPAR bool • RPAR
   42 bool: bool • OR bool
   43     | bool • AND bool

    RPAR  décalage et aller à l'état 75
    AND   décalage et aller à l'état 76
    OR    décalage et aller à l'état 77


État 58

   32 then: THEN •
   34     | THEN •

    NUM      réduction par utilisation de la règle 32 (then)
    NUM      [réduction par utilisation de la règle 34 (then)]
    ID       réduction par utilisation de la règle 32 (then)
    ID       [réduction par utilisation de la règle 34 (then)]
    FLOAT    réduction par utilisation de la règle 32 (then)
    FLOAT    [réduction par utilisation de la règle 34 (then)]
    STRING   réduction par utilisation de la règle 32 (then)
    STRING   [réduction par utilisation de la règle 34 (then)]
    LPAR     réduction par utilisation de la règle 32 (then)
    LPAR     [réduction par utilisation de la règle 34 (then)]
    IF       réduction par utilisation de la règle 32 (then)
    IF       [réduction par utilisation de la règle 34 (then)]
    $défaut  réduction par utilisation de la règle 32 (then)


État 59

   29 if_exp: if cond then • atom_exp else atom_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7

    atom_exp     aller à l'état 78
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 60

   38 funcall_exp: ID LPAR arg_list RPAR •

    $défaut  réduction par utilisation de la règle 38 (funcall_exp)


État 61

   40 arg_list: arg_list VIR • arith_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    arith_exp    aller à l'état 79
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 62

   10 id_list: ID •

    $défaut  réduction par utilisation de la règle 10 (id_list)


État 63

    9 fun_head: ID LPAR id_list • RPAR
   11 id_list: id_list • VIR ID

    RPAR  décalage et aller à l'état 80
    VIR   décalage et aller à l'état 81


État 64

    7 def_id: LET ID EQ exp •

    $défaut  réduction par utilisation de la règle 7 (def_id)


État 65

    8 def_fun: LET fun_head EQ exp •

    $défaut  réduction par utilisation de la règle 8 (def_fun)


État 66

   27 atom_exp: LPAR exp • RPAR
   45 bool: exp • comp exp

    RPAR   décalage et aller à l'état 41
    ISLT   décalage et aller à l'état 69
    ISGT   décalage et aller à l'état 70
    ISLEQ  décalage et aller à l'état 71
    ISGEQ  décalage et aller à l'état 72
    ISEQ   décalage et aller à l'état 73

    comp  aller à l'état 74


État 67

   42 bool: bool • OR bool
   43     | bool • AND bool
   46     | LPAR bool • RPAR

    RPAR  décalage et aller à l'état 82
    AND   décalage et aller à l'état 76
    OR    décalage et aller à l'état 77


État 68

   42 bool: bool • OR bool
   43     | bool • AND bool
   44     | NOT bool •

    $défaut  réduction par utilisation de la règle 44 (bool)


État 69

   47 comp: ISLT •

    $défaut  réduction par utilisation de la règle 47 (comp)


État 70

   48 comp: ISGT •

    $défaut  réduction par utilisation de la règle 48 (comp)


État 71

   49 comp: ISLEQ •

    $défaut  réduction par utilisation de la règle 49 (comp)


État 72

   50 comp: ISGEQ •

    $défaut  réduction par utilisation de la règle 50 (comp)


État 73

   51 comp: ISEQ •

    $défaut  réduction par utilisation de la règle 51 (comp)


État 74

   45 bool: exp comp • exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 83
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21


État 75

   31 cond: LPAR bool RPAR •

    $défaut  réduction par utilisation de la règle 31 (cond)


État 76

   43 bool: bool AND • bool

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 53
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    NOT     décalage et aller à l'état 54
    BOOL    décalage et aller à l'état 55
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 56
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21
    bool         aller à l'état 84


État 77

   42 bool: bool OR • bool

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 53
    LET     décalage et aller à l'état 6
    IF      décalage et aller à l'état 7
    NOT     décalage et aller à l'état 54
    BOOL    décalage et aller à l'état 55
    MOINS   décalage et aller à l'état 8

    let_def      aller à l'état 23
    def_id       aller à l'état 12
    def_fun      aller à l'état 13
    exp          aller à l'état 56
    arith_exp    aller à l'état 15
    atom_exp     aller à l'état 16
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    let_exp      aller à l'état 20
    funcall_exp  aller à l'état 21
    bool         aller à l'état 85


État 78

   29 if_exp: if cond then atom_exp • else atom_exp

    ELSE  décalage et aller à l'état 86

    else  aller à l'état 87


État 79

   15 arith_exp: arith_exp • MOINS arith_exp
   16          | arith_exp • PLUS arith_exp
   17          | arith_exp • DIV arith_exp
   18          | arith_exp • MULT arith_exp
   19          | arith_exp • CONCAT arith_exp
   40 arg_list: arg_list VIR arith_exp •

    PLUS    décalage et aller à l'état 32
    MOINS   décalage et aller à l'état 33
    MULT    décalage et aller à l'état 34
    DIV     décalage et aller à l'état 35
    CONCAT  décalage et aller à l'état 36

    $défaut  réduction par utilisation de la règle 40 (arg_list)


État 80

    9 fun_head: ID LPAR id_list RPAR •

    $défaut  réduction par utilisation de la règle 9 (fun_head)


État 81

   11 id_list: id_list VIR • ID

    ID  décalage et aller à l'état 88


État 82

   46 bool: LPAR bool RPAR •

    $défaut  réduction par utilisation de la règle 46 (bool)


État 83

   45 bool: exp comp exp •

    $défaut  réduction par utilisation de la règle 45 (bool)


État 84

   42 bool: bool • OR bool
   43     | bool • AND bool
   43     | bool AND bool •

    $défaut  réduction par utilisation de la règle 43 (bool)


État 85

   42 bool: bool • OR bool
   42     | bool OR bool •
   43     | bool • AND bool

    AND  décalage et aller à l'état 76

    $défaut  réduction par utilisation de la règle 42 (bool)


État 86

   33 else: ELSE •
   35     | ELSE •

    NUM      réduction par utilisation de la règle 33 (else)
    NUM      [réduction par utilisation de la règle 35 (else)]
    ID       réduction par utilisation de la règle 33 (else)
    ID       [réduction par utilisation de la règle 35 (else)]
    FLOAT    réduction par utilisation de la règle 33 (else)
    FLOAT    [réduction par utilisation de la règle 35 (else)]
    STRING   réduction par utilisation de la règle 33 (else)
    STRING   [réduction par utilisation de la règle 35 (else)]
    LPAR     réduction par utilisation de la règle 33 (else)
    LPAR     [réduction par utilisation de la règle 35 (else)]
    IF       réduction par utilisation de la règle 33 (else)
    IF       [réduction par utilisation de la règle 35 (else)]
    $défaut  réduction par utilisation de la règle 33 (else)


État 87

   29 if_exp: if cond then atom_exp else • atom_exp

    NUM     décalage et aller à l'état 1
    ID      décalage et aller à l'état 2
    FLOAT   décalage et aller à l'état 3
    STRING  décalage et aller à l'état 4
    LPAR    décalage et aller à l'état 5
    IF      décalage et aller à l'état 7

    atom_exp     aller à l'état 89
    control_exp  aller à l'état 17
    if_exp       aller à l'état 18
    if           aller à l'état 19
    funcall_exp  aller à l'état 21


État 88

   11 id_list: id_list VIR ID •

    $défaut  réduction par utilisation de la règle 11 (id_list)


État 89

   29 if_exp: if cond then atom_exp else atom_exp •

    $défaut  réduction par utilisation de la règle 29 (if_exp)
